\chapter{Реализация и экспериментальные исследования}
\label{chapter3}

В данной главе рассмотрены подробности реализации гибридного алгоритма, а также результаты экспериментов по сравнению реализованного алгоритма с уже существующими.

\section{Реализация гибридного алгоритма}

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{ENS-NDT-ONE}{P, M, B}
    \State{$S \gets CreateSplits(P, M-1,B)$}
    \State{$P \gets Sort(P, a^M \prec b^M, ..., a^1 \prec b^1)$}
    % \State{$R \gets ReorederBySort(P, R)$}
    \State{$\mathcal{F} \gets \{\{P_1\}\}$}
    \State{$\mathcal{T} \gets new NDTreeOne(S, B)$}
    \State{$InsertIntoNDTreeOne(\mathcal{T}, P_1)$}
    \State{$j \gets 1$}
    \For{$i = 2, ..., |P|$}
        \If{$P_{i-1} \neq P_{i}$}
            \State {$j \gets FindRankInNDTreeOne(\mathcal{T}, P_i)$}
            \State{$InsertIntoNDTreeOne(\mathcal{T}, \mathcal{P}_i)$}
        \EndIf
        \State{$\mathcal{F}_j \gets \mathcal{F}_j \cup {P_i}$}
    \EndFor
    \State{\Return {$\mathcal{F}$}}
\EndProcedure
\end{algorithmic}
\caption{Главная процедура алгоритма ENS-NDT-ONE.}
\label{procedure_end_ndt_one}
\end{algorithm}

В данном разделе будут описаны подробности реализации гибридного алгоритма. 

\subsection{Адаптация алгоритма Густавссона}

Основным изменением алгоритма ENS-NDT стало то, что вместо множества деревьев для каждого ранга, теперь в структуре одно дерево. Новый алгоритм назван ENS-NDT-ONE, на листинге ~\ref{procedure_end_ndt_one} приведен псевдокод основного метода этого алгоритма, который принимает в качестве аргументов множество точек P, M - размерность и B - порог, максимальное количество точек в вершине. Для получения split структуры используется функция CreateSplits, о которой можно почитать в первой главе данной работы.

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{FindRankInNDTreeOne}{$\mathcal{T}, p, r$}
    \If {$ maxRank < r$}
        \State {\Return {r}}
    \EndIf

    \If{$p[\mathcal{T}.splitCoordinate] >= \mathcal{T}.splitValue$}
        \State {$r \gets FindRankInNDTreeOne(\mathcal{T}.worseNode, P_i, r)$}     
    \EndIf
    \State {$r \gets FindRankInNDTreeOne(\mathcal{T}.betterNode, P_i, r)$}     
    
    \State{\Return {$r$}}
\EndProcedure
\end{algorithmic}
\caption{Процедура поиска ранга точки с предварительным рангом в нетерминальной вершине.}
\label{procedure_find_rank_n_term}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{FindRankInNDTreeOne}{$\mathcal{T}, p, r$}
    \If {$maxRank < r$}
        \State {\Return {r}}
    \EndIf
    \For{$i = |\mathcal{T}.points|, ..., 1$}
        \If {$\mathcal{T}.points[i] \prec p$}
            \State {\Return {$\mathcal{T}.ranks[i] + 1$}}
        \EndIf
    \EndFor
    \State{\Return {$r$}}
\EndProcedure
\end{algorithmic}
\caption{Процедура поиска ранга точки с предварительным рангом в терминальной вершине.}
\label{procedure_find_rank_term}
\end{algorithm}

Для адаптации в функцию $FindRankInNDTreeOne$ будет добавлен дополнительный аргумент, ранг точки $P_i$, тогда функция $FindRankInNDTreeOne$ в терминальной вершине будет иметь реализацию представленную на листинге ~\ref{procedure_find_rank_term}. А в нетерминальной вершине реализация представляет из себя два рекурсивных вызова на вершинах-потомках с одним только отсечением, если координата рассматриваемой вершины больше либо равна медианному значению, то в левого ребенка можно не заходить, то есть в поддерево, где по текущей координате все точки больше рассматриваемой, не найдется ни одной точки, которая бы доминировала нашу, следовательно заходить в такое поддерво нет смысла. На листинге ~\ref{procedure_find_rank_n_term} представлен псевдокод определения ранга в нетерминальной вершине.

\subsubsection{HelperA}

Адаптация для функции $HeplerA$ полностью совпадает с самим алгоритмом ENS-NDT-ONE, учитывая только то, что точки имеют на изначальный ранг. То есть помимо множества точек в функцию приходят ранги точек. 

\subsubsection{HelperВ}

Для функции $HeplerB$ немного сложнее, представим псевдокод основного метода алгоритма ENS-NDT-ONE на листинге ~\ref{procedure_end_ndt_one_helper_b}. Множество точек L уже окончательно отранжированы в базовом алгоритма ``Разделяй и властвуй'', множество точек R имеют некоторые предварительно проставленные ранги. Задача метода обновить ранги точек множества R на основе рангов точек множества L. 

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{ENS-NDT-ONE-HelperB}{$L, R, M, B, Ranks$}
    \State{$S \gets CreateSplits(L, M-1,B)$}
    \State{$\mathcal{T} \gets new NDTreeOne(S, B)$}
    \State{$InsertIntoNDTreeOne(\mathcal{T}, P_1)$}
    \State{$j \gets 1$}
    \For{$p \in L \cup R$}
        \State {$r \gets p.rank$}
        \If{$p \in L$} 
            \State{$InsertIntoNDTreeOne(\mathcal{T}, p, r)$}
        \EndIf
        \If{$p \in R$} 
            \State{$r \gets FindRankInNDTreeOne(\mathcal{T}, p, r)$}
        \EndIf
    \EndFor
    \State{\Return {$\mathcal{Ranks}$}}
\EndProcedure
\end{algorithmic}
\caption{Главная процедура алгоритма ENS-NDT-ONE, адаптированная для переключения в момент $HeplerB$.}
\label{procedure_end_ndt_one_helper_b}
\end{algorithm}

Первым интересным моментом является то, что split структуру мы будем строить только для множества точек L, то есть точки из множества R никак не влияют друг на друга и обновляются только на основе рангов точек L. Так же добавлять в структуру мы будет только точки из множества L, а точки из R мы будем только ранжировать. Так как точки приходят из базового алгоритма в отсортированном порядке дополнительно делать лексикографическую сортировку нет необходимости. Таким образом мы перебираем объединение точек L и R в лексикографическом порядке. 

Мы реализовали гибридный алгоритм на основе алгоритма Буздалова и алгоритма Густавссона. 

\section{Настройка параметров гибридного алгоритма}

Настройка гибридного алгоритма будет представлять некоторый диапазон размеров множеств точек для каждой размерности, при котором происходит переключение. Параметры основаны на экспериментальных данных и не зависят от размера множеств точек на которых запускается гибридный алгоритм недоминирующей сортировки. Другими словами, эти параметры можно считать константами. 

Наше экспериментальное исследование показало, что для размерности три оптимальным переключением будет, когда размер множества точек не привышает 100, а при размерностях больше трех переключение необходимо осуществлять на множествах точек размером не более $20 000$. 

\section{Сравнение с существующими алгоритмами на искусственно сгенерированных тестовых данных}

В данном разделе приводится сравнение эффективности работы нового гибридного алгоритма с существующими. Сравнение производилось с двумя родительскими алгоритмами, которые в свою очередь являются лучшими алгоритмами недомиринующей сортировки на сегодняшний день, и с адаптацией алгоритма END-NDT-ONE работающей самостоятельно.

Замеры времени работы производились на множестве точек размером до $10^6$ с размерностями 3, 5, 7, 10, 15, на случайно сгенерированных независимых точках в гиперкубе $[0; 1]^M$ и на точках расположенных на одной гиперплоскости и имеющих один ранг. Серым обозначены лучшие в каждой группе алгоритмы.

\newcommand{\best}{\cellcolor{gray!50!white}}

\begin{table}[!ht]
\caption{Среднее время работы алгоритмов в секундах. Лучшее время в каждой категории обозначено серым цветом.}\label{results}
\begin{tabular}{rr|rr|rr|rr|rr}
$N$&$M$ & \multicolumn{2}{c|}{Divide\&Conquer} 
        & \multicolumn{2}{c|}{ENS-NDT} 
        & \multicolumn{2}{c|}{ENS-NDT-ONE} 
        & \multicolumn{2}{c}{Hybrid} \\
& & {\scriptsize hypercube} & {\scriptsize hyperplane} 
  & {\scriptsize hypercube} & {\scriptsize hyperplane} 
  & {\scriptsize hypercube} & {\scriptsize hyperplane} 
  & {\scriptsize hypercube} & {\scriptsize hyperplane} \\\hline
$5\cdot10^5$&$3$  & $1.52$ & $0.85$ & $1.95$ & $0.73$ & $1.66$ & $0.76$ & \best $1.17$ & \best $0.67$\\
      $10^6$&$3$  & $2.82$ & $1.60$ & $5.25$ & $1.61$ & $4.25$ & $1.65$ & \best $2.63$ & \best $1.50$\\\hline
$5\cdot10^5$&$5$  & $22.7$ & $16.6$ & $8.31$ & \best $2.01$ & \best $6.25$ & $2.22$ & $6.43$ & $4.68$\\
      $10^6$&$5$  & $45.2$ & $33.0$ & $26.3$ & \best $5.22$ & $18.2$ & $5.82$ & \best $17.2$ & $12.8$\\\hline
$5\cdot10^5$&$7$  & $89.6$ & $55.1$ & $17.1$ & $6.96$ & $15.5$ & \best $6.78$ & \best $9.29$ & $7.02$\\
      $10^6$&$7$  & $191.5$& $120.2$& $55.4$ & $19.4$ & $46.1$ & \best $18.9$ & \best $26.8$ & $20.1$\\\hline
$5\cdot10^5$&$10$ & $197.7$& $99.9$ & $27.6$ & $15.9$ & $36.7$ & $17.7$ & \best $14.5$ & \best $11.5$\\
      $10^6$&$10$ & $478.8$& $228.6$& $84.8$ & $48.1$ & $104.8$& $55.0$ & \best $41.0$ & \best $33.0$\\\hline
$5\cdot10^5$&$15$ & $190.0$& $116.1$& $40.8$ & $23.0$ & $62.1$ & $25.9$ & \best $22.6$ & \best $15.7$\\
      $10^6$&$15$ & $587.9$& $337.5$& $135.4$& $76.3$ & $206.8$& $85.4$ & \best $64.5$ & \best $46.0$\\\hline
\end{tabular}
\end{table}

Для каждой конфигурации ввода было создано 10 экземпляров с разными случайно сгенерированными точками. Мы измерили общее время во всех этих случаях и разделили их на 10, чтобы получить среднее временя выполнения. Измерения времени выполнялись с использованием пакета Java Microbenchmark Harness с одной итерацией прогрева не менее 6 секунд, чего было достаточно для стабилизации работы программы. Был использован высокопроизводительный сервер с процессорами AMD OpteronTM 6380 и 512 GB ОЗУ, а код был запущен с виртуальной машиной OpenJDK 1.8.0 141.
Репозиторий с кодом представлен на GitHub, также там можно найти графики времени работы. В таблице 1 показаны только средние результаты для $ N = 5 \cdot 10 ^ 5 $ и $ 10 ^ 6 $. Видно, что гибридный алгоритм выигрывает во всех случаях, кроме $ M = 5 $ и $ M = 7 $ на гиперплоскоти. Еще одно интересное наблюдение, что ENS-NDT-ONE работает быстрее, чем ENS-NDT, на экземплярах гиперкуба с $ M \leq 7 $, что означает, что предложенная эвристика действительно эффективна. Однако константа реализации ENS-NDT-ONE немного больше.

\section{Адаптация для многопоточного выполнения}

Алгоритм адаптирован для многопоточного выполнения, ускорение составляет до $1.8$ на двух потоках и до трех раз на восьми потоках.

\section{Сравнение с существующими алгоритмами на практических задачах}
В данном разделе будут приведены сравнение работы гибридного алгоритма на реальных практических задачах.


