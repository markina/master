\chapter{Методы разработки гибридных алгоритмов недоминирующей сортировки}
\label{chapter2}

В данной главе описана схема гибридного алгоритма, приведены требования к кандидатам на роль алгоритмов, на основе которых разрабатывается гибридный алгоритм, приведена адаптация существующих алгоритмов и описан гибридный алгоритм на основе существующих. 

\section{Отбор алгоритмов, подходящих для создания гибридного алгоритма}

Основным кандидатом для создания гибридного алгоритма недоминирующей сортировки оказался алгоритм Буздалова и др. на основе метода <<разделяй и властвуй>>. Есть две основные причины, чтобы использовать этот алгоритм:

\begin{enumerate}
 \item Данный алгоритм основан на методе <<разделяй и властвуй>>, что позволяет использовать рекурсивные вызовы к качестве точек подключения с одного алгоритма на другой.
 \item Данный алгоритм является одним из лучших алгоритмов на сегодняшний день и имеет хорошую доказанную асимптотику времени работы.
\end{enumerate}

Вторым кандидатом стал алгоритм Роя, который уже показал неплохие результаты в гибриде с алгоритмом Буздалова~\cite{Markina}, но алгоритм Роя был приспособлен для гибридизации только при вызове $HelperA$. То есть только в трех из пяти случаев, когда существует возможность переключиться на другой алгоритм. В этой работе представлена попытка приспособить алгоритм Роя к переключению на него внутри процедуры $HelperB$. 

Третьим кандидатом стал алгоритм Густавссона ENS-NDT, использование которого для создания гибридного алгоритма сильно снизило эффективность гибридного алгоритма недоминирующей сортировки. Вдохновившись идеями алгоритма Густавссона, мы получили новый алгоритм и назвали его ENS-NDT-ONE. Сам по себе он уже имеет некоторый научный интерес, так как имеет хорошую асимптотику и эффективен на практике наравне с лучшими алгоритмами недоминирующей сортировки. Затем мы реализовали гибридный алгоритм на основе алгоритма Буздалова и алгоритма ENS-NDT-ONE.

\section{Предлагаемая схема гибридного алгоритма}

В этом разделе будет описана предлагаемая схема гибридного алгоритма.

\subsection{Выбор момента переключения}

Алгоритм Буздалова очень хорошо подходит для создания гибридного алгоритма недоминирующей сортировки, так как в алгоритме рекурсивно вызывается этот же алгоритм на множествах меньшего размера и меньшей размерности. Данный алгоритм подробно описан в Главе~\ref{chapter1}. В оригинальной статье функции, где мы предполагаем переключаться на другой алгоритм, названы $HeplerA$ и $HeplerB$. Мы предлагаем следующую идею создания гибридного алгоритма: 
\begin{enumerate}
  \item Запускаем алгоритм Divide\&Conquer, согласно некоторым правилам переключаемся на другой алгоритм.
  \item Моменты смены алгоритма:
    \begin{enumerate}
    \item HelperA
      \begin{enumerate}
      \item Входные данные: множество точек $S$ с предварительными рангами.
      \item Результат выполнения: множество точек $S$ с обновленными рангами.
      \end{enumerate}
    \item HelperB  
      \begin{enumerate}
      \item Входные данные: множество точек $L$ с окончательными рангами и $R$ с предварительными рангами.
      \item Результат выполнения: множество точек $R$ с обновленными рангами по множеству $L$.
      \end{enumerate}
    \end{enumerate}
\end{enumerate}

% TODO Добавить рисунок 

\subsection{Настройка параметров переключения}

Настройка гибридного алгоритма будет представлять некоторый диапазон размеров множества точек для каждой размерности, при котором происходит переключение. Например, при размерности точек три, договоримся, что смена алгоритма происходит если точек не больше $100$, а при размерности $4$ и более смена происходит при размере множеств точек не более $1000$. Параметры гибридизации получаются экспериментальным путем для конкретного вида гибридного алгоритма. Параметры, полученные в данной работе, описаны в Разделе 4.3.

\section{Адаптация существующих алгоритмов}

В этом разделе описана адаптация алгоритмов для создания гибридного алгоритма. Для этой цели было выбрано два алгоритма: алгоритм Роя и алгоритм Густавссона. Идеи гибридизации и адаптации схожи, поэтому опишем их сначала в общем случае, а потом перейдем к деталям каждого алгоритма. 

Функция $HeplperA$ {---} это сама недоминирующая сортировка, поэтому приспосабливать алгоритмы с этой точки зрения не надо.

Напомним, что функция $HeplerB$ в качестве входных параметров принимала два множества $L$ с окончательными рангами и $R$ с предварительными рангами, по результату работы назначаются ранги множеству точек $R$ по множеству точек $L$. 

Для $HeplerB$ была предложена следующая идея адаптации для гибридизации: 
\begin{enumerate}
  \item Обходим точки из множества $|L| \cup |R|$в порядке, предложенном в оригинальном алгоритме.
  \begin{enumerate}
      \item Если точка принадлежит множеству с окончательными рангами $L$, добавляем точку в структуру алгоритма с текущим рангом.
      \item Если точка принадлежит множеству с предварительными рангами $R$, то мы определяем ранг рассматриваемой точки на основе текущего состояния структуры и не добавляем ее в структуру, так как ранжирование происходить только на основе точек из множества $L$.
  \end{enumerate}
\end{enumerate}

Основные отличия от оригинальных алгоритмов: 
\begin{enumerate}
    \item В оригинальных статьях на момент начала работы алгоритмов все точки имели ранг $0$, в нашем же случае начальные ранги могут быть любыми.
    \item Определение ранга точек надо изменить, чтобы алгоритм учитывал предпоставленные ранги.
\end{enumerate}

Рассмотрим отдельно для каждого алгоритма адаптацию для последующей реализации гибридного алгоритма.

\subsection{Алгоритм Роя и др.}

Алгоритм, предложенный Роем и др. описан подробно в Главе~\ref{chapter1}. Ранее был предложен гибридный алгоритм, который может переключаться на другой алгоритм в момент вызова алгоритмом Буздалова процедуры $HelperA$~\cite{Markina}, при этом возможность переключения на другой алгоритм в момент вызова $HelperB$ не была рассмотрена в данной работе. 

Определение ранга в оригинальном алгоритме происходит бинарным или последовательным поиском с нулевого ранга по ранжированному множеству точек. Эффективность этих двух подходов практически совпадала. Найденное множество точек с минимальным рангом, где ни одна точка не доминирует рассматриваемую, означало, что точке можно присвоить ранг этого множества. Справедлив следующий инвариант: для рассматриваемой точки до некоторого ранга $k$ все множества, соответствующие меньшим $k$ рангам, имеют хотя бы одну точку, которая доминирует рассматриваемую, а начиная с множества соответствующего рангу $k$ и больше во всех множествах нет ни одной точки, которая бы доминировала рассматриваемую точку. В таком случае точка получает ранг $k$. 

В новой версии алгоритма в множестве $L$, точки которого добавляются в структуру позволяющую определять ранг, могут иметь совершенно любые ранги. И точка может доминироваться точкой, например, ранга $k$, но не доминироваться точкой $k-1$ ранга, это означает, что больше нельзя использовать бинарный поиск для определения ранга. Единственным выходом является перебор множеств начиная с наибольшего в структуре, пока не найдется множество, где есть хотя бы одна точка, которая доминирует рассматриваемую. После этого можно сделать вывод, что точка имеет ранг найденного множества + 1. 

После такого значительного изменения алгоритма мы провели замеры времени работы, и оказалось, что новый алгоритм работает на порядок хуже оригинального алгоритма. Это означает, что создать эффективный гибридный алгоритм на его основе нельзя, по крайней мере используя такой подход гибридизации. Теоретическое исследование времени алгоритма является достаточно трудоемкой задачей, и из-за настолько плохого практического результата оно не было проведено. 

\subsection{Алгоритм Густавссона и др.}

Следующим кандидатом для гибридизации был алгоритм Густавссона и др. 

Время работы этого алгоритма на случайно сгенерированных независимых точках в гиперкубе составляет $O(N^{1.43})$, но авторами работы описан худший случай, на котором асимптотика становится квадратичной и составляет $O(MN^2)$. На больших $N$ время работы становится неприемлемо большим. Алгоритм выбран в качестве основного кандидата для гибридизации, потому что он является самым эффективным алгоритмом на сегодняшний день в общем случае. 

В оригинальном алгоритме точки, которые необходимо отсортировать, инициализируются рангом $0$, и ранг назначается постепенно, в лексикографическом порядке. В гибридном алгоритме точки в качестве аргументов приходят в алгоритм Густавссона из базового алгоритма Буздалова. Если никак не модифицировать оригинальный алгоритм Густавссона, то возможна следующая ситуация, при которой ранги могут быть расставлены неправильно: вновь добавляемая точка не доминируется ни одной точки с рангом $0$ (то есть оригинальный алгоритм может поставить ранг $0$), при этом добавляемая точка может доминировать точкой с рангом больше $0$. 

В оригинальном алгоритме Густавссона определение ранга происходит похожим на алгоритм Роя образом. В структуре недоминирующих деревьев, где каждое дерево соответствует своему рангу, мы бинарным поиском определяется минимально по рангу дерево. И если ни одна точка дерева не доминирует рассматриваемую, тогда рассматриваемой точке присваивался ранг этого дерева. Но аналогично проблеме описанной выше для алгоритма Роя, в алгоритме Густавссона инвариант позволяющий осуществить бинарный поиск перестает работать. Теперь определении ранга точки необходимо искать точку с максимальным рангом, которая доминирует точку, ранг которой определяется. Тогда этой точке назначается ранг найденной точки $+ 1$.  

По этой причине алгоритм был адаптирован следующим образом: вместо бинарного поиска использовался последовательный перебор с дерева, соответствующего максимальному рангу, переходя к деревьям меньшего ранга. После этого мы провели эмпирический анализ времени работы, который показал, что потеря монотонности критически влияет на время работы. Теоретический анализ адаптированного алгоритма не был произведен, из-за плохого практического результата.

Описанные выше сложности вдохновили на создание нового алгоритма на основе недоминирующего дерева, на которое отсутствие монотонности не производило бы такого сильного замедления. Новый алгоритм был названный ENS-NDT-ONE, описан в Главе~\ref{chapter3}.


